# Практика 3. Детектирование объектов с использованием каскадного классификатора

[![Feedback](feedback.png)][feedback_day3]

## Цели

__Цель данной работы__ -  изучить программные средства библиотеки 
OpenCV, позволяющие обучать и применять каскадные детекторы объектов.

## Задачи

__Основные задачи__

  1. Разработать приложение, осуществляющее детектирование объектов 
     определенного класса на одиночном изображении и видео с помощью каскадного классификатора.
  1. Обучить детекторы логотипов ННГУ и OpenCV на основе HAAR- и LBP-признаков.
  1. Применить полученные самостоятельно детекторы и стандартные детекторы 
     из состава OpenCV к тестовым видео. Визуально сравнить качество различных 
     детекторов для одних и тех же объектов.

__Дополнительные задачи__
  
  1. Разработать приложение, позволяющее детектировать объекты нескольких классов
     на одном изображении/видео одновременно.
  1. Разработать приложение, осуществляющее детектирование объектов
     на изображении и видео с помощью HOG-детектора
     (см. документацию [`HOGDescriptor`][hog-documentation]).
  1. Добавить в разработанное приложение возможность оценки качества детектирования
     при наличии файла с описанием истинных положений объектов на изображении/кадрах видео,
     используя класс `DetectionQualityEvaluator`, объявленный в файле `include/benchmark.hpp`. 

## Общая структура программного модуля

В лабораторной работе основные задачи решаются на базе программного
модуля `detection` библиотеки `summer_school_2016_lib`. Модуль
включает заголовочный файл `include\detection.hpp`
и исходный файл`src\detection.cpp`. Модуль содержит объявление
абстрактного класса `Detector`.

```cpp
class Detector {
 public:
  static std::shared_ptr<Detector> CreateDetector(const std::string& name);
  virtual bool Init(const std::string& model_file_path) = 0;
  virtual void Detect(const cv::Mat& frame, std::vector<cv::Rect>& objects,
                      std::vector<double>& scores) = 0;
};
```

Класс имеет следующие чисто виртуальные методы:

  1. `Init` - метод загрузки детектора из файла.
  1. `Detect` - метод детектирования объектов на одиночном изображении.
     Входные параметры: `frame` - изображение.
     Выходные параметры: `objects` - вектор прямоугольников,
     выделяющих найденные объекты на изображении;
     `scores` - вектор, содержащий для каждого срабатывания детектора число,
     определяющее уверенность детектора в наличии объекта 
     в соответствующей области изображения.

Также класс содержит [фабричный метод][factory-method] `CreateDetector`.
  
## Общая последовательность действий

  1. Объявить класс-наследник `CascadeDetector` от класса `Detector`.
  1. Последовательно реализовать методы класса `CascadeDetector`.
  1. Скопировать `samples\template_demo.cpp` в директорию `samples`.
  1. Переименовать копию примера в `samples\detection_demo.cpp`.
  1. Разработать приложение `samples\detection_demo.cpp` в соответствии
     с перечнем требований, представленным в описании основных задач.
  1. Разработать приложения, решающие дополнительные задачи.

## Детальная инструкция по выполнению работы

  1. Дополнить заголовочный файл `include\detection.hpp` объявлением 
     класса `CascadeDetector`, унаследовав его от класса `Detector`.

  ```cpp
  class CascadeDetector : public Detector {
   public:
    virtual bool Init(const std::string& model_file_path);
    virtual void Detect(const cv::Mat& frame, std::vector<cv::Rect>& objects,
                        std::vector<double>& scores);

   protected:
    cv::CascadeClassifier detector;
  };
  ```

  1. Добавить код для создания экземпляра класса `CascadeDetector` в фабричный метод
     `Detector::CreateDetector`.

  ```cpp
  if (name == "cascade") {
    return std::make_shared<CascadeDetector>();
  }
  ```

  1. Реализовать метод `CascadeDetector::Init`. Метод предполагает
     выполнение следующей последовательности действий:
  
     1. Произвести загрузку каскадного детектора из файла, с помощью метода `load`
        класса [`cv::CascadeClassifier`][cascade-documentation].
     1. Обработать возможные ошибки при загрузке детектора 
        и вернуть `true` при успешной загрузке, иначе `false`.
  
  1. Реализовать метод `CascadeDetector::Detector`. Метод предполагает
     выполнение следующей последовательности действий:
     
     1. Проверить был ли загружен детектор из файла ранее.
     1. Если детектор был загружен, то осуществить детектирование
        объектов на пирамиде изображений с использованием метода
        `cv::CascadeClassifier::detectMultiScale`.
     1. В качестве значения параметра `score` вернуть число срабатываний детектора,
        пришедшихся на один объект.

  1. Сделать копию файла `samples\template_demo.cpp` под именем `samples\detection_demo.cpp`.
  1. Разработать приложение `samples\detection_demo.cpp` в соответствии
     с требованиями, перечисленными в основных задачах.
     
     1. Создать массив опций приложения: `image` - путь до исходного
        изображения; `video` - путь до исходного видеофайла;
        `camera` - идентификатор камеры, с которой требуется получить видеопоток;
        `model` - путь до файла детектора.
        Опции `image`, `video` и `camera` взаимоисключающие.

     ```cpp
     const char* kOptions =
        "{ i image        | <none> | image to process                         }"
        "{ v video        | <none> | video to process                         }"
        "{ c camera       | <none> | camera to get video from                 }"
        "{ m model        | <none> | path to detector file                    }"
        "{ h ? help usage |        | print help message                       }";
     ```

     1. Создать экземпляр класса `CascadeDetector` и загрузить детектор из файла.

     1. Загрузить изображение/очередной кадр видео и выполнить детектирование на нем.

     1. Отрисовать все срабатывания детектора в виде прямоугольников
        на изображении и отобразить результат.

  1. Загрузить один из готовых детекторов из директории
     `test/test_data/detection/cascades/` и визуально оценить качество его работы на
     тестовом видео (`test/test_data/video/logo.mp4`) или/и видео с веб-камеры.
     Также можно протестировать готовые модели для детектирования лиц/людей,
     которые предоставляются в составе библиотеки OpenCV
     (`<source-каталог OpenCV>/data/*cascades/`).

  1. Поочередно обучить детекторы на LBP- и HAAR-признаках для одного из логотипов
     из директории `test/test_data/detection/positives`.

     1. Скопировать папку `test/test_data/detection/negatives/`
        и файл `test/test_data/detection/negatives.txt` в текущую рабочую директорию.

     1. Запустить приложение `opencv_traincascade` из состава OpenCV
        (`<build-каталог OpenCV>/bin/opencv_traincascade` или 
        `<build-каталог OpenCV>/x64/vc*/bin/opencv_traincascade`), указав следующие параметры:

        * `-vec <путь до vec-файла с позитивными примерами>`.
          Готовые vec-файлы c 2000 позитивов для некоторых логотипов можно найти в
          директории `test/test_data/detection/vec_files/`.

        * `-numPos <кол-во позитивов для тренировки>`.

        * `-bg <путь до файла со списком негативных изображений>`. Файл `negatives.txt`
          как раз и содержит такой список.

        * `-numNeg <кол-во негативов для тренировки>`.

        * `-featureType <тип используемых признаков>`. Выберите HAAR или LBP.

        * `-data <путь до директории для сохранения полученного детектора>`.
          Директорию требуется создать заранее!

        * `-w <ширина объекта в пикселях> -h <высота объекта в пикселях>`.
          Так задается минимальный размер детектируемого объекта.

        * `-numStages <максимальное кол-во стадий каскада>`.

        * `-maxFalseAlarmRate <максимально допустимая частота ложных срабатываний>`.


     ```bash
     $ opencv_traincascade -vec logo.vec -numPos 500 -bg negatives.txt -numNeg 500 -featureType HAAR -maxFalseAlarmRate 0.1 -numStages 5 -w 32 -h 32 -data logo_cascade
     ```

        Замечание: работа данного приложения может занять несколько минут
        и время может существенно меняться в зависимости 
        от указанных значений параметров.

  1. Сгенерировать vec-файл для выбранного лого самостоятельно
     и повторить обучение детектора. Для генерации vec-файла
     предназначено приложение `opencv_createsamples`
     (`<build-каталог OpenCV>/bin/opencv_createsamples` или
     `<build-каталог OpenCV>/x64/vc*/bin/opencv_createsamples`).
     Данное приложение позволяет сгенерировать выборку позитивных изображений
     путем применения случайных геометрических преобразований
     и изменения яркости заданного позитивного изображения, а также
     наложения результата на негативное изображение.
     Запуск приложения без параметров приводит к перечислению всех допустимых
     параметров.

  ```bash
  $ opencv_createsamples -img logo.png -bgthresh 1 -bg negatives.txt -maxxangle 0.7 -maxyangle 0.7 -maxzangle 0.5 -num 2000 -w 32 -h 32 -vec logo.vec
  ```
        
  1. Разработать приложения, решающие дополнительные задачи.


<!-- LINKS -->

[cascade-documentation]: http://docs.opencv.org/master/d1/de5/classcv_1_1CascadeClassifier.html
[hog-documentation]: http://docs.opencv.org/master/d5/d33/structcv_1_1HOGDescriptor.html
[feedback_day3]: https://docs.google.com/forms/d/1gyrYDnRgoHUZ_URK5j4p7lrXw6FEtk5tBYwo6eND7GI/viewform
[factory-method]: https://sourcemaking.com/design_patterns/factory_method
