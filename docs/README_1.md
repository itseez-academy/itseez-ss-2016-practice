# Практика 1. Инструменты разработки ПО

## Цели

__Цель данной работы__ - освоить следующие инструменты 
разработки программного обеспечения:

  - Утилита [CMake](http://www.cmake.org) для сборки исходных кодов.
  - Система контроля версий [Git](https://git-scm.com/book/en/v2).
  - [Google Testing Framework](https://code.google.com/p/googletest).

## Задачи

__Основные задачи__

  1. Создать собственную копию (на сервере) для рабочего репозитория, содержащего
     практические задания школы.
  1. Создать локальную копию (на рабочей машине) репозитория, содержащего
     практические задания школы.
  1. Настроить локальную копию репозитория для последующей синхронизации
     версии с сервером.
  1. Реализовать функцию отсечения элементов двумерного массива типа `unsigned char`.
     Предполагается, что двумерный массив развернут в одномерный по строкам.
     Функция отсечения заменяет каждое значение на 0, если текущее значение
     элемента меньше заданного порога.
  1. Разработать тесты для реализованной функции отсечения.
  1. Закоммитить разработанную функцию в локальный репозиторий.
  1. Отправить Pull Request в основной репозиторий, содержащий шаблоны
     практических заданий школы.

__Дополнительные задачи__

  1. Реализовать функцию усреднения элементов в заданной окрестности.
     Например, если `src[i, j]` - исходное значение элемента
     (`i`, `j`) и размер окрестности равен 1, то новое значение элемента
     вычисляется согласно формуле, приведенной ниже.
  
  ```
  dst[i, j] = (src[i - 1, j - 1] + src[i - 1, j] + src[i - 1, j + 1] + 
               src[i,     j - 1] + src[i,     j] + src[i,     j + 1] +
               src[i + 1, j - 1] + src[i + 1, j] + src[i + 1, j + 1]) / 9
  ```

     В общем случае, `dst[i, j]` равно среднему арифметическому элементов `src[i + t, j + s]`
     при `t=-k..k` и `s=-k..k`, где `k` - размер окрестности.
  
  1. Реализовать функцию медианной фильтрации изображения.
     `dst[i, j]` равно среднему по величине элементу окрестности `src[i + t, j + s]`,
     `t=-k..k` и `s=-k..k`, где `k` - размер окрестности.
     
  
## Общая последовательность действий

  1. Сделать форк upstream-репозитория.
  1. Клонировать origin-репозиторий к себе на локальную машину (раздел
     [Общие инструкции по работе с Git][git-intro]).
  1. Собрать проект и проверить его работоспособность, запустив тесты и пример
     (раздел [Сборка проекта с помощью CMake и MS VS][cmake-msvs]).
  1. Создать рабочую ветку (раздел [Общие инструкции по работе с Git][git-intro]).
  1. Реализовать функцию отсечения элементов двумерного массива типа `unsigned char`.
     По мере готовности не забывайте выкладывать изменения в рабочую ветку на сервер.
  1. Разработать тесты для реализованной функции отсечения.
  1. Сделать Pull Request в upstream-репозиторий.
  1. Решить задачи списка [Дополнительные задачи][tasks].

## Общие инструкции по работе с Git

В данном разделе описана типичная последовательность действий, которую
необходимо выполнить перед тем, как начать работать с проектом. Далее
для определенности используется репозиторий `itseez-ss-2016-practice`.

  1. Создать аккаунт на [github.com](https://github.com), если такой
     отсутствует. Для определенности обозначим аккаунт `github-account`.

  1. Сделать fork репозитория
     <https://github.com/itseez-academy/itseez-ss-2016-practice> (в
     терминологии Git upstream-репозиторий) к себе в личный профиль с названием
     `github-account`. В результате будет создана копия репозитория 
     <https://github.com/github-account/itseez-ss-2016-practice>
     (origin-репозиторий).

  1. Клонировать [origin][origin] репозиторий к себе на локальный компьютер,
     воспользовавшись следующей командой:

  ```bash
  $ git clone https://github.com/github-account/itseez-ss-2016-practice
  ```

  1. Перейти в директорию `itseez-ss-2016-practice`:

  ```bash
  $ cd ./itseez-ss-2016-practice
  ```

  1. Настроить адрес upstream-репозитория (потребуется при обновлении локальной
     версии репозитория):

  ```bash
  $ git remote add upstream https://github.com/itseez-academy/itseez-ss-2016-practice
  ```

  1. Настроить имя пользователя и e-mail, из под которого будут выполняться
     все операции с репозиторием Git:

  ```bash
  $ git config --local user.name "github-account"
  $ git config --local user.email "github-email"
  ```

  Примечание: если не выполнить указанную операцию при попытке
  размещения изменений на сервер, они попадут под аккаунтом пользователя
  компьютера.
  
  1. Настроить редактор, который будет испольвазован, если вносятся изменения
     в историю репозитория (в частиности, при слиянии веток).
  
  ```bash
  $ git config --local core.editor "'c:/program files/sublime text 2/sublime_text.exe' -n -w"
  ```

Когда сделан форк репозитория у вас создается по умолчанию единственная ветка
master. Тем не менее, при решении независимых задач следует создавать рабочие
ветки. Далее показаны основные команды для управления ветками на примере ветки
`practice-1`.

  1. Получить список веток:

  ```bash
  $ git branch [-v]
  # [-v] - список с информацией о последних коммитах
  ```

  1. Создать ветку:

  ```bash
  $ git branch practice-1
  ```

  1. Создать ветку `practice-1` и перейти в нее:

  ```bash
  $ git checkout [-b] practice-1
  # [-b] - создание и переход в ветку <branch_name>
  ```
  1. Удалить ветку в локальном репозитории:

  ```bash
  $ git branch -d <branch_name>
  ```

  1. Удалить ветку на сервере:

  ```bash
  $ git push [remotename] :[branch]
  # [remotename] - имя удалённого репозитория. Если следовать приведённой
  #     инструкции, то origin - репозиторий пользователя github-account, upstream -
  #     репозиторий itseez-academy/itseez-ss-2016-practice
  ```

При работе с файлами в ветке необходимо управлять изменениями. Далее приведен
перечень основных команд в предположении, что текущей рабочей веткой
является `practice-1`.

  1. Получить список текущих изменений:

  ```bash
  $ git status
  ```

  1. Пометить файл как добавленный в текущую ветку репозитория (файл будет
     добавлен после выполнения команды `commit`):

  ```bash
  $ git add [<file_name>]
  # <file_name> - название файла для добавления в commit
  #     если вместо имени указан символ *, то будут добавлены все новые файлы,
  #     не совпадающие с масками, указанными в .gitignore
  ```

  1. Добавить изменения в текущую ветку локального репозитория:

  ```bash
  $ git commit [-m "<message_to_commit>"] [-a]
  # [-a] - автоматически добавляет изменения для существующих на сервере файлов
  #     без выполнения команды git add
  # [--amend] - перезаписывает последний коммит (используется, если не забыты
  #     изменения)
  ```

  1. Разместить изменения, которые были добавлены в локальный репозиторий
     с помощью команды `commit`:

  ```bash
  $ git push [-u] origin [practice-1]
  # [-u] - отслеживать версию ветки [practice-1] на удалённом сервере
  #     (origin). Позволяет получать изменения с сервера при помощи команды git pull
  #     без явного указания имени удалённого репозитория и имени ветки.
  ```

  1. Получить изменения с сервера при помощи команды `pull` и слить их с
     отслеживаемыми ветками:

  ```bash
  $ git pull [remotename [<branch name>]]
  ```

  1. Удалить файлы или директории (!без опции `-f` для файлов, состояния
     которых совпадают с состояниям на сервере):

  ```bash
  $ git rm [-f] [--cached]
  # [-f] - принудительное удаление (файла с измененным состоянием)
  # [--cached] - удаление файлов на сервере, но не в локальной директории
  ```

  1. Переименовать файлы (или 3 команды: `mv`, `git rm`, `git add`):

  ```bash
  $ git mv <file_from> <file_to>
  ```

Когда в проекте работает несколько человек, то вполне естественная ситуация -
необходимость слияния изменений и разрешение конфликтов.

  1. Слияние (вариант 1):

  ```bash
  $ git merge upstream/master # слияние изменений из ветки upstream в master
  $ git merge master # слияние изменений из ветки master в текущую ветку
  ```

  1. Слияние (вариант 2):

  ```bash
  $ git checkout <branch_name> # переход в ветку <branch_name> (при необходимости)
  $ git rebase <base_branch> [<branch_name>] # слияние изменений из ветки <base_branch> в ветку <branch_name>
  $ git checkout <base_branch>
  $ git merge <branch_name>
  ```

  1. Инструмент для разрешения конфликтов:

  ```bash
  $ git mergetool
  ```

## Сборка проекта с помощью CMake и Microsoft Visual Studio 2015

В данном разделе описана типичная последовательность действий, которую
необходимо выполнить для сборки проекта с использованием утилиты CMake и
Microsoft Visual Studio 2015. Далее для определенности выполняется сборка проекта
из репозитория `itseez-ss-2016-practice`.

  1. Рядом с директорией `itseez-ss-2016-practice` создайте
     `itseez-ss-2016-practice-build`. В новой директории будут размещены файлы
     решения и проектов, сгенерированные с помощью CMake.

     ```bash
     $ cd ..
     $ mkdir itseez-ss-2016-practice-build
     ```

  1. Перейдите в директорию `itseez-ss-2016-practice-build`:

     ```bash
     $ cd ./itseez-ss-2016-practice-build
     ```

  1. Сгенерируйте файлы решения и проектов с помощью утилиты CMake. Для этого
     можно воспользоваться графическим приложением, входящим в состав
     утилиты, либо выполнить следующую команду:

  ```bash
  $ cmake -DOpenCV_DIR="<OpenCVConfig.cmake-path>" -G <generator-name> <path-to-itseez-ss-2016-practice>
  # <OpenCVConfig.cmake-path> - директория, в которой установлена
  #     библиотека OpenCV и расположен файл OpenCVConfig.cmake
  # <generator-name> - название генератора, в случае тестовой
  #     инфраструктуры участников школы может быть "Visual Studio 14 2015 Win64"
  #     (если в командной строке набрать cmake без параметров, то можно просмотреть
  #     список доступных генераторов)
  # <path-to-itseez-ss-2016-practice> - путь до директории
  #     itseez-ss-2016-practice, где лежат исходные коды проекта (если предыдущие действия
  #     выполнены корректно, то это директория`../itseez-ss-2016-practice`)
  ```
  Обратите внимание, что для сборки проекта необходима версия OpenCV 3.1.x,
  например, 3.1.0, которую можно скачать [здесь](http://opencv.org/downloads.html).
  В терминал-классах OpenCV 3.1.0 установлена в директорию `C:\OpenCV31`

  1. Откройте сгенерированный файл решения `summer_school_2016.sln`. В терминал-классах
     Microsoft Visual Studio располагается по пути:
     `C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\devenv.exe`
  1. Нажмите правой кнопкой мыши по проекту `ALL_BUILD` и выберите пункт
     `Rebuild` контекстного меню, чтобы собрать решение. В результате все
     бинарные файлы будут размещены в директории
     `itseez-ss-2016-practice-build/bin`.
  1. Для запуска приложения и тестов откройте командную строку (`cmd.exe` в `Пуск`)
     и перейдите в директорию с бинарными файлами, используя команду `cd`.
  1. Можно запустить шаблонное приложение `template_demo.exe`. Возможное сообщение
     при запуске: `The program can't start because
     opencv_world310.dll is missing from your computer. Try reinstalling
     the program to fix this problem.`. Решение 1: скопировать
     соответствующую библиотеку из `C:\OpenCV31\opencv\build\x64\vc14\bin`
     к бинарным файлам проекта. Решение 2: добавить путь `C:\OpenCV31\opencv\build\x64\vc14\bin`
     в переменную окружения `PATH`.
  1. По аналогии следует запустить тесты `test_summer_school_2016.exe`. В результате
     прохождения тестов появится список тестов и их статус.

## Детальная инструкция по выполнению работы

  1. Сделать форк upstream-репозитория.
  
     1. Открыть в браузере upstream-репозиторий
        https://github.com/itseez-academy/itseez-ss-2016-practice.
     1. В правом верхем углу нажать кнопку Fork.
     1. Выбрать в качестве организации, куда направить форк, организацию,
        соответствующую вашему аккаунту `@github-account`.

  1. Клонировать origin-репозиторий к себе на локальную машину (раздел
     [Общие инструкции по работе с Git][git-intro]).
     
     1. Открыть командную строку Git Bash (или Git Shell в зависимости от того,
        какой git-клиент установлен на вашей машине). Для этого необходимо найти
        соответствующий ярлык на рабочем столе или в меню "Пуск".
     1. Воспользоваться перечнем инструкций, описанных в разделе
        [Общие инструкции по работе с Git][git-intro]).
     
  1. Собрать проект и проверить его работоспособность, запустив тесты и пример
     (раздел [Сборка проекта с помощью CMake и MS VS][cmake-msvs]).
     
     1. Воспользоваться инструкцией по сборке и запуску, описанной в разделе
        [Сборка проекта с помощью CMake и MS VS][cmake-msvs]).
     1. Чтобы проверить работоспособность тестов и сэмпла, достаточно запустить
        `test_summer_school_2016.exe` и `template_demo.exe`. Если все тесты
        "зеленые" и сэмпл отработал, то можно двигаться дальше.

     ```bash
     $ cd itseez-ss-2016-practice-build/bin
     $ test_summer_school_2016.exe
     $ template_demo.exe
     ```
  
  1. Создать рабочую ветку (раздел [Общие инструкции по работе с Git][git-intro]).
  1. Реализовать метод отсечения элементов двумерного массива типа `unsigned char`.
     Объявление метода находится в файле `workaround.hpp`, класс `MatrixProcessor`,
     а реализация метода - в файле `workaround.cpp`. По мере готовности
     не забывайте выкладывать изменения в рабочую ветку на сервер.
  1. Разработать тесты для реализованной функции отсечения.
  1. Собрать проект и проверить работоспособность разработанного примера
     использования функции отсечения (раздел
     [Сборка проекта с помощью CMake и MS VS][cmake-msvs]).
  1. Сделать Pull Request в upstream-репозиторий.
  1. Решить задачи списка [Дополнительные задачи][tasks].

<!-- LINKS -->

[origin]: https://github.com/github-account/itseez-ss-2016-practice
[git-intro]: https://github.com/itseez-academy/itseez-ss-2016-practice/blob/master/docs/README_1.md#Общие-инструкции-по-работе-с-git
[cmake-msvs]: https://github.com/itseez-academy/itseez-ss-2016-practice/blob/master/docs/README_1.md#Сборка-проекта-с-помощью-cmake-и-microsoft-visual-studio-2015
[tasks]: https://github.com/itseez-academy/itseez-ss-2016-practice/blob/master/docs/README_1.md#Задачи
